

#' Subcluster a small graph and save the results to file
#'
#' @param sub Subgraph to be clustered and saved
#' @param network.dir Directory where nodes.tsv, edges.tsv, net.pdf will be saved (filenames autogenerated)
#' @param orig.graph The original graph which is needed to recover the edge directions
#'
#' @return
#'
#' @examples
save_small_subgraph<-function(sub, network.dir, orig.graph){

  # add number of nodes to filename
  counter <-igraph::vcount(sub)
  ## Add timestamp to avoid overwriting same sized graphs
  timestamp = as.numeric(format(Sys.time(), "%OS3")) * 1000

  local.dir<-file.path(network.dir, paste0('net_', counter, '_',timestamp))
  dir.create(local.dir, recursive = TRUE)
  # Create filename
  file.plot <- file.path(local.dir, paste0('net.pdf'))
  file.edge <- file.path(local.dir, paste0('edges.tsv'))
  file.node<-file.path(local.dir, paste0('nodes.tsv'))


  # Layout and create submodules
  lay <- igraph::layout_with_kk(sub)
  go<- igraph::cluster_fast_greedy(sub)


  sub<-igraph::subgraph(orig.graph, igraph::V(sub)$name)
  # Plot network
  pdf(file = file.plot, width = 600, height = 600 )
  plot(go, sub , vertex.size = 5, edge.arrow.size = 1, vertex.label.cex = 1)
  dev.off()

  # save edge list
  edgelist<-data.table::as.data.table(igraph::as_edgelist(sub) )
  colnames(edgelist)<-c('source', 'target')
  data.table::fwrite(edgelist, file = file.edge , sep = '\t')

  # save nodelist with community
  nodelist<-data.table::data.table(node=go$names, module.greedy=go$membership)
  data.table::fwrite(nodelist, file = file.node, sep = '\t')
}


#' Recursively cluster and save the modules
#'
#' @param gr Current subgraph
#' @param network.dir Output dir (trailed along)
#' @param orig.graph Original graph (trailed along)
#'
#' @return
#'
#' @examples
cluster<-function(gr, network.dir, orig.graph){
  # recursive function subdividing the network
  # until a size of less than 200 nodes is reached
  # At 200 or fewer nodes the network is clustered one last
  # time to obtain modules and saved.
  groups<-igraph::cluster_fast_greedy(gr)
  group_sizes<-table(groups$membership)
  for (cl in names(group_sizes)){
    gs <- group_sizes[cl]
    sub<-igraph::subgraph(gr, which(groups$membership==cl))
    if (gs>150){
      cluster(sub, network.dir, orig.graph)
    }
    else if (gs<200 & gs>50){

      save_small_subgraph(sub, network.dir, orig.graph)
    }
  }
}


#' Title
#'
#' @param net.dir
#' @param collectri_file
#'
#' @return
#' @export
#'
#' @examples
clusterCollecTRI<-function(net.dir, collectri_file){
  # Main function to cluster collectri network.
  # Check if collectri is stored on disk
  # otherwise download from web
  if (!file.exists(collectri_file)){
    # get network
    collectri <- decoupleR::get_collectri(organism='human', split_complexes=FALSE)
    data.table::fwrite(collectri, file = collectri_file , sep = '\t')
  }
  else{
    collectri = data.table::fread(collectri_file, sep = '\t')
  }
  ## make undirected graph (required for greedy clustering)
  collectri$mor<-1
  g<-igraph::graph_from_data_frame(collectri, directed = FALSE, vertices = NULL)
  orig.graph <- igraph::graph_from_data_frame(collectri, directed = TRUE, vertices = NULL)
  ## delete multiedges (required for greedy clustering)
  m<-which(igraph::which_multiple(g))
  g<-igraph::delete_edges(g, m)


  # Create network directory
  dir.create(net.dir, recursive = T)

  # call recursive clustering function.
  cluster(g, net.dir, orig.graph)
}


#' Remove networks which contain only one or 2 hubnodes
#'
#' @param basedir Directory containing network files with the ending ".edges.tsv"
#'
#' @return edgelist: A list of files relative to the basedir containing networks with more than 1 hubnode
#' @export
#'
#' @examples
remove_irrelevant_networks<-function(basedir){
  edgelists<-list.files(basedir, pattern = '.*edges.tsv', recursive = T)
  hedgehogs<-c()
  betweenness_list<-list()

  for( e in edgelists){
    net<-data.table::fread(file.path(basedir, e))
    g<-igraph::graph_from_data_frame(net, directed = FALSE, vertices = NULL)
    bet<- igraph::betweenness(g)
    #print(sort(bet))

    if (length(which(bet>0))<3){
      # remove networks with one gene regulating all the others
      hedgehogs<-c(hedgehogs, e)
    }
    else{
      betweenness_list[[e]]<-data.table::data.table(betweeness = bet, name = rep(e, length(bet)))
    }
  }

  edgelists<-setdiff(edgelists, hedgehogs)
  netlist<-data.table::data.table(net.filename<-c(edgelists, hedgehogs), type = c(rep('modularized', length(edgelists)), rep('hedgehog', length(hedgehogs))))
  data.table::fwrite(netlist, file = file.path(basedir, 'network_stats.tsv'), sep = '\t')

  return(edgelists)
}

## Helper function to color the nodes
color<-function(x, n = 3){
  pal<-viridis::inferno(n)
  return(pal[x])
}

## Compute spectral clustering
#' Use spectral clustering to partition the graph into n.cluster
#'
#' @param edgelist file with list of network files
#' @param basedir  Directory
#' @param n.clusters number of clusters to produce
#'
#' @return
#' @export
#'
#' @examples
cluster_and_plot<-function(edgelist, basedir, n.clusters = 3){
  for (e in edgelist){
    net<-data.table::fread(file.path(basedir, e))
    g<-igraph::graph_from_data_frame(net, directed = FALSE, vertices = NULL)
    #plot(g, vertex.size = 5, edge.arrow.size = 1, vertex.label.cex = 1)

    ## Spectral clustering
    clu <- igraph::embed_laplacian_matrix(g, no=n.clusters, type = 'DAD', which = 'la')
    km <- stats::kmeans(clu[["X"]], centers =n.clusters)

    nodes.file <- file.path(basedir, gsub('edges.tsv', 'nodes.tsv', e))
    nodes<-data.table::fread(nodes.file, sep = '\t')

    columnname<-paste0('cluster.spectral.', n.clusters)
    node.clu<-data.table::data.table(igraph::V(g)$name,km$cluster)
    colnames(node.clu)<-c('name', columnname)

    nodes<-merge(nodes, node.clu, by.x = 'node', by.y = 'name')
    data.table::fwrite(nodes, file = nodes.file, sep = '\t')

    igraph::V(g)$color<-sapply(km$cluster, function(x) color(x,n.clusters))

    file.plot <- file.path(basedir,  gsub('edges.tsv', paste0('spectral_', n.clusters, '.pdf'), e))
    pdf(file = file.plot, width = 600, height = 600 )
    plot(g, vertex.size = 5, edge.arrow.size = 1, vertex.label.cex = 1)
    dev.off()
  }
}



