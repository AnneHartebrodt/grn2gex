
#' Subcluster a small graph and save the results to file
#'
#' @param sub Subgraph to be clustered and saved
#' @param network_dir Directory where nodes.tsv, edges.tsv, net.pdf will be saved (filenames autogenerated)
#' @param orig_graph The original graph which is needed to recover the edge directions
#'
#'
#' @return A list of objects
#' @export
#'
#' @examples
restore_original_directionality<-function(sub, orig_graph){

  go<- igraph::cluster_fast_greedy(sub)
  sub<-igraph::subgraph(orig_graph, igraph::V(sub)$name)
  sub<-igraph::simplify(sub, remove.loops = TRUE)
  edgelist<-data.table::as.data.table(igraph::as_edgelist(sub) )
  colnames(edgelist)<-c('source', 'target')
  nodelist<-data.table::data.table(node=go$names, module_greedy=go$membership)

  results<-list(sub, go, nodelist, edgelist)
  names(results)<-c('subgraph', 'clustering', 'nodelist', 'egdelist')
  return(results)
}


#' Recursively cluster and save the modules
#'
#' @param gr Current subgraph
#' @param network_dir Output dir (trailed along)
#' @param orig_graph Original graph (trailed along)
#'
cluster<-function(gr, min_nodes=50, max_nodes= 200){
  # recursive function subdividing the network
  # until a size of less than 200 nodes is reached
  # At 200 or fewer nodes the network is clustered one last
  # time to obtain modules and saved.
  groups<-igraph::cluster_fast_greedy(gr)
  group_sizes<-table(groups$membership)
  list_of_nets<-list()

  print(min_nodes)
  print(max_nodes)

  for (cl in names(group_sizes)){
    gs <- group_sizes[cl]
    sub<-igraph::subgraph(gr, which(groups$membership==cl))
    if (gs>max_nodes){

      list_of_nets<-c(list_of_nets, cluster(sub, min_nodes = min_nodes, max_nodes = max_nodes))
    }
    else if (gs<max_nodes & gs>min_nodes){
      list_of_nets<-c(list_of_nets, list(sub))
    }
  }
return(list_of_nets)
}


#' Convenience function to either use an existing collectri file or download it from the web via DecouplR.
#'
#' @param collectri_file Filename of the Collectri file, if exists will be used, otherwise downloaded via decoupleR and saved
#'
#' @return A data.table with the network of the specified organism
#' @export
#'
#' @examples
#' collectri_file <- '/tmp/collectri.tsv'
#' collectri <- loadOrDownloadCollectTRI(collectri_file)
loadOrDownloadCollectTRI<-function(collectri_file, organism = 'human'){
  # Main function to cluster collectri network.
  # Check if collectri is stored on disk
  # otherwise download from web
  options(omnipathr.curl_verbose = TRUE)
  OmnipathR::omnipath_set_cachedir(tempdir())

  if (!file.exists(collectri_file)){
    # get network
    collectri <- decoupleR::get_collectri(organism=organism, split_complexes=FALSE)
    dir.create(dirname(collectri_file))
    data.table::fwrite(collectri, file = collectri_file , sep = '\t')
  }
  else{
    collectri = data.table::fread(collectri_file, sep = '\t')
  }
  return(collectri)
}


#' Wrapper function to cluster a network in a datatable.
#'
#' @param network_dt A data.table containing a colum 'source' and 'target' as the first and second column
#'
#' @return A list of igraph Graph objects
#' @export
#'
#' @examples
#' collectri.file <- '/tmp/collectri.tsv'
#' collectri <- loadOrDownloadCollectTRI(collectri.file)
#' colnames(collectri)<- c('source', 'target', 'sad')
#' netlist<-clusterNetwork(collectri )
clusterNetwork<-function(network_dt, min_nodes=50, max_nodes= 200){
  g<-createGraph(network_dt, directed = FALSE)
  # call recursive clustering function.
  return(cluster(g, min_nodes, max_nodes))
}

#' Create Graph from data.table.
#'
#' @param network_dt A data.table containing at least a colum 'source' and 'target' as the first and second column
#' @param directed set to true if the igraph object should contain directed edges (no greedy clustering possible)
#'
#' @return An igraph object without multi-egdes
#' @export
#'
#' @examples
#' collectri_file <- '/tmp/collectri.tsv'
#' collectri <- loadOrDownloadCollectTRI(collectri_file)
#' colnames(collectri)<- c('source', 'target', 'weight')
#' orig_graph<-createGraph(collectri)
createGraph<-function(network_dt, directed = FALSE){
  if (colnames(network_dt)[1]!='source') BBmisc::stopf('Make sure the first column has title source')
  if (colnames(network_dt)[2]!='target') BBmisc::stopf('Make sure the second column has title target')

  g<-igraph::graph_from_data_frame(network_dt, directed = directed, vertices = NULL)
  ## delete multiedges (required for greedy clustering)
  m<-which(igraph::which_multiple(g))
  g<-igraph::delete_edges(g, m)
  return(g)
}


#' Remove networks which contain only one or two hubnodes
#' @description Networks which contain only one or two hubnodes and no structure otherwise may
#' not be of interest and can be removed with this function.
#'
#'
#' @param graph_list A list of igraph objects
#'
#' @return List of igraph objects containing networks with more than 2 hubnodes
#' @export
#'
#' @examples
#' collectri_file <- '/tmp/collectri.tsv'
#' collectri <- loadOrDownloadCollectTRI(collectri_file)
#' colnames(collectri)<- c('source', 'target', 'sad')
#' netlist<-clusterNetwork(collectri )
#' netlist<-remove_irrelevant_networks(netlist)
#'
remove_irrelevant_networks<-function(graph_list){

  hedgehogs<-c()
  relevant <-c()
  betweenness_list<-list()

  for( g in graph_list){
    bet<- igraph::betweenness(g)

    if (length(which(bet>0))<3){
      # remove networks with one gene regulating all the others
      hedgehogs<-c(hedgehogs, list(g))
    }
    else{
      relevant<-c(relevant, list(g))
    }
  }
  return(relevant)
}

#' Convenience function to either use an existing collectri file or download it from the web via DecouplR.
#'
#' @param network. A data table with source and target columns
#'
#' @return A data.table with the data table of the subnetwork
#' @export
#'
subsample_and_sparsify_network <- function(network, num_sources, max_out_degree) {
  if (colnames(network)[1]!='source') BBmisc::stopf('Make sure the first column has title source')
  if (colnames(network)[2]!='target') BBmisc::stopf('Make sure the second column has title target')

  # Convert to data.table for efficient manipulation
  network_dt <- as.data.table(network)

  # Get unique source and target nodes
  all_sources <- unique(network_dt$source)
  all_targets <- unique(network_dt$target)

  # Check if there are enough sources and targets to sample from
  if (length(all_sources) < num_sources) {
    stop("Not enough unique source nodes in the network to sample from.")
  }


  # Randomly select a subset of sources and targets
  sampled_sources <- sample(all_sources, num_sources, replace = FALSE)

  # Filter the network to keep only the sampled sources and targets
  subnetwork <- network_dt[source %in% sampled_sources]

  # Sparsify the subnetwork by limiting outgoing connections
  # We group by the source and keep at most `max_out_degree` connections.

  sparsified_subnetwork <- subnetwork %>%
    group_by(source) %>%
    slice_head(n = max_out_degree) %>%
    ungroup() %>%
    as.data.table()

  sparsified_subnetwork<-sparsified_subnetwork[!(target %in% sparsified_subnetwork$source)]

  return(sparsified_subnetwork)
}

