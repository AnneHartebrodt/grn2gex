

#' Subcluster a small graph and save the results to file
#'
#' @param sub Subgraph to be clustered and saved
#' @param network.dir Directory where nodes.tsv, edges.tsv, net.pdf will be saved (filenames autogenerated)
#' @param orig.graph The original graph which is needed to recover the edge directions
#'
#' @return NULL
#'
#' @examples
#' collectri <- loadOrDownloadCollectTRI(collectri.file)
#' colnames(collectri)<- c('source', 'target', 'sad')
#' graph_list<-clusterNetwork(collectri )

#' graph_list<-remove_irrelevant_networks(graph_list)
#' orig_graph<-createGraph(collectri)
#' for (g in graph_list){
#'  save_small_subgraph(g, net.dir, orig_graph)
#' }
save_small_subgraph<-function(sub, network.dir, orig.graph){

  # add number of nodes to filename
  counter <-igraph::vcount(sub)
  ## Add timestamp to avoid overwriting same sized graphs
  timestamp = as.numeric(format(Sys.time(), "%OS3")) * 1000

  local.dir<-file.path(network.dir, paste0('net_', counter, '_',timestamp))
  dir.create(local.dir, recursive = TRUE)
  # Create filename
  file.plot <- file.path(local.dir, paste0('net.pdf'))
  file.edge <- file.path(local.dir, paste0('edges.tsv'))
  file.node<-file.path(local.dir, paste0('nodes.tsv'))


  # Layout and create submodules
  lay <- igraph::layout_with_kk(sub)
  go<- igraph::cluster_fast_greedy(sub)


  sub<-igraph::subgraph(orig.graph, igraph::V(sub)$name)
  # Plot network
  pdf(file = file.plot, width = 600, height = 600 )
  plot(go, sub , vertex.size = 5, edge.arrow.size = 1, vertex.label.cex = 1)
  dev.off()

  # save edge list
  edgelist<-data.table::as.data.table(igraph::as_edgelist(sub) )
  colnames(edgelist)<-c('source', 'target')
  data.table::fwrite(edgelist, file = file.edge , sep = '\t')

  # save nodelist with community
  nodelist<-data.table::data.table(node=go$names, module.greedy=go$membership)
  data.table::fwrite(nodelist, file = file.node, sep = '\t')
}



#' Recursively cluster and save the modules
#'
#' @param gr Current subgraph
#' @param network.dir Output dir (trailed along)
#' @param orig.graph Original graph (trailed along)
#'
cluster<-function(gr, min_nodes=50, max_nodes= 200){
  # recursive function subdividing the network
  # until a size of less than 200 nodes is reached
  # At 200 or fewer nodes the network is clustered one last
  # time to obtain modules and saved.
  groups<-igraph::cluster_fast_greedy(gr)
  group_sizes<-table(groups$membership)
  list_of_nets<-list()

  for (cl in names(group_sizes)){
    gs <- group_sizes[cl]
    sub<-igraph::subgraph(gr, which(groups$membership==cl))
    if (gs>max_nodes){

      list_of_nets<-c(list_of_nets, cluster(sub))
    }
    else if (gs<max_nodes & gs>min_nodes){
      list_of_nets<-c(list_of_nets, list(sub))
    }
  }
return(list_of_nets)
}


#' Convenience function to either use an existing collectri file or download it from the web via DecouplR.
#'
#' @param collectri_file Filename of the Collectri file, if exists will be used, otherwise downloaded via decoupleR and saved
#'
#' @return A data.table with the network of the specified organism
#' @export
#'
#' @examples collectri_file<- '/path/to/myfile'
#' collectri <- loadOrDownloadCollectTRI(collectri_file)
loadOrDownloadCollectTRI<-function(collectri_file, organism = 'human'){
  # Main function to cluster collectri network.
  # Check if collectri is stored on disk
  # otherwise download from web
  if (!file.exists(collectri_file)){
    # get network
    collectri <- decoupleR::get_collectri(organism=organism, split_complexes=FALSE)
    dir.create(dirname(collectri_file))
    data.table::fwrite(collectri, file = collectri_file , sep = '\t')
  }
  else{
    collectri = data.table::fread(collectri_file, sep = '\t')
  }
  return(collectri)
}


#' Wrapper function to cluster a network in a datatable.
#'
#' @param network_dt A data.table containing a colum 'source' and 'target' as the first and second column
#'
#' @return A list of igraph Graph objects
#' @export
#'
#' @examples
#' collectri <- loadOrDownloadCollectTRI(collectri.file)
#' colnames(collectri)<- c('source', 'target', 'sad')
#' netlist<-clusterNetwork(collectri )

clusterNetwork<-function(network_dt){
  g<-createGraph(network_dt, directed = FALSE)
  # call recursive clustering function.
  return(cluster(g))
}

#' Create Graph from data.table.
#'
#' @param network_dt A data.table containing at least a colum 'source' and 'target' as the first and second column
#' @param directed set to true if the igraph object should contain directed edges (no greedy clustering possible)
#'
#' @return An igraph object without multi-egdes
#' @export
#'
#' @examples
#' collectri <- loadOrDownloadCollectTRI(collectri_file)
#' colnames(collectri)<- c('source', 'target', 'weight')
#' orig_graph<-createGraph(collectri)
for (g in graph_list){
  save_small_subgraph(g, net.dir, orig_graph)
}
createGraph<-function(network_dt, directed = FALSE){
  if (colnames(network_dt)[1]!='source') BBmisc::stopf('Make sure the first column has title source')
  if (colnames(network_dt)[2]!='target') BBmisc::stopf('Make sure the second column has title target')

  g<-igraph::graph_from_data_frame(network_dt, directed = directed, vertices = NULL)
  ## delete multiedges (required for greedy clustering)
  m<-which(igraph::which_multiple(g))
  g<-igraph::delete_edges(g, m)
  return(g)
}


#' Remove networks which contain only one or two hubnodes
#' @description Networks which contain only one or two hubnodes and no structure otherwise may
#' not be of interest and can be removed with this function.
#'
#'
#' @param graph_list A list of igraph objects
#'
#' @return List of igraph objects containing networks with more than 2 hubnodes
#' @export
#'
#' @examples
#' collectri <- loadOrDownloadCollectTRI(collectri.file)
#' colnames(collectri)<- c('source', 'target', 'sad')
#' netlist<-clusterNetwork(collectri )
#' netlist<-remove_irrelevant_networks(netlist)
#'
remove_irrelevant_networks<-function(graph_list){

  hedgehogs<-c()
  relevant <-c()
  betweenness_list<-list()

  for( g in graph_list){
    bet<- igraph::betweenness(g)

    if (length(which(bet>0))<3){
      # remove networks with one gene regulating all the others
      hedgehogs<-c(hedgehogs, list(g))
    }
    else{
      relevant<-c(relevant, list(g))
    }
  }
  return(relevant)
}


